// Generated by CoffeeScript 1.7.1
(function() {
  var Client, Message, digest, net, sip, _;

  net = require('net');

  sip = require('sip');

  digest = require('sip/digest');

  _ = require('underscore');

  Client = function(options) {
    this.options = _.defaults(options, Client.defaultOptions);
	this.messages = {};
    this.events = {};
	
    this.socket = net.connect({
      port: this.options.port,
      host: this.options.host
    },
    function() { //'connect' listener
		return  Client_x.events["connected"] && Client_x.events["connected"].forEach(function(cb) {
          return cb({});
        });
	});

    /*this.sipSocket = sip.start({
      port: 31337
    });*/
	
	var Client_x = this;
	
    this.socket.setTimeout(10000);
	
	this.socket.on('error', (err) => {
		if(this.socket)
			this.socket.end();
	});
	
	this.socket.on('close', (function(_this) {

		return  Client_x.events["connection_closed"] && Client_x.events["connection_closed"].forEach(function(cb) {
          return cb({});
        });
	}));
	
    this.socket.on('data', (function(_this) {
      return function(d) {
        return _this.receive(d);
      };
    })(this));
	
   
    this.sip = sip;
	
    return this;
  };

  Client.defaultOptions = {
    debug: false,
    port: 5060
  };

  Client.uuid = function() {
    var f;
    f = function() {
      return Math.floor((1 + Math.random()) * 0x100000).toString(16);
    };
    return [f(), f(), f(), f()].join('-');
  };

  Client.log = function(msg, out) {
    var char;
    if (out == null) {
      out = true;
    }
    char = out === true ? '>' : '<';
    char += ' ';
    msg = msg.split("\n").map(function(line) {
      return char + line;
    }).join("\n");
	if(msg.trim() != ""){ return console.log(msg);}
	return false;
  };

  Client.prototype.send = function(string) {
    this.options.debug && Client.log(string);
    return this.socket.write(string);
  };

  Client.prototype.on = function(evt, callback) {
    evt = evt.toLowerCase();
    this.events[evt] = this.events[evt] || [];
    return this.events[evt].push(callback);
  };

  Client.prototype.receive = function(data) {
    var challenge, challenge_header, method, msg, request, response, status;
    msg = sip.parse(data.toString());
    this.options.debug && Client.log(data.toString(), false);
    status = msg.status;
    if (status === 100) {
      return;
    }
    request = this.messages[msg.headers['call-id']];
    switch (status) {
      case void 0:
        method = msg.method.toLowerCase();
		
		if( method == "invite"){
			//request.inc_cseq();
			this.send(sip.stringify({status: 100,reason: "Trying",headers: msg.headers}));
			
//			request.inc_cseq();
			this.send(sip.stringify({status: 180,reason: "Ringing",headers: msg.headers}));
		}
		
        return this.events[method] && this.events[method].forEach(function(cb) {
          return cb(msg);
        });
      case 200:
        return request.events.success.forEach(function(cb) {
          return cb(msg);
        });
      case 401:
      case 407:
	  
        challenge_header = status === 401 ? "www-authenticate" : "proxy-authenticate";
        challenge = msg.headers[challenge_header][0];
        challenge.realm = challenge.realm.replace(/"/g, '');
        request.inc_cseq();
        response = digest.signRequest([challenge], request, msg, {
          user: this.options.user,
          realm: challenge.realm,
          password: this.options.password
        });
        return this.send(sip.stringify(request));
	  case 487:
		return request.events.call_terminated.forEach(function(cb) {
          return cb(msg);
        });
    }
  };

  Client.prototype.message = function(method, uri, headers, body) {
    var m;
    if (body == null) {
      body = '';
    }
    m = new Message(method, uri, headers, body, this.options.host, this.options.user);
    m.client = this;
    return this.messages[m.callid] = m;
  };

  Message = function(method, uri, headers, body, host, user) {
    var defaultHeaders, parts;
    this.seq = 1;
    this.callid = Client.uuid();
    this.events = {
      'success': [],
      'fail': []
    };
    this.method = method.toUpperCase();
    if (typeof uri === 'string') {
      parts = uri.split('@');
      if (parts.length === 1) {
        host = uri;
      } else {

      }
      uri = {
        schema: schema || 'sip',
        user: user,
        host: host
      };
    }
    uri.schema = uri.schema || 'sip';
    uri.host = host || host;
    this.uri = uri;
    defaultHeaders = {
      'call-id': this.callid,
      from: {
        uri: {
          schema: uri.schema,
          host: host,
          user: user
        }
      },
      via: [
        {
          version: '2.0',
          protocol: 'tcp',
          host: uri.host
        }
      ],
      cseq: {
        seq: 1,
        method: this.method
      },
	  allow: "INVITE, ACK, CANCEL, BYE, NOTIFY, REFER, MESSAGE, OPTIONS, INFO, SUBSCRIBE",
	  Expires: 3600,
	  "User-Agent": "Node-Red-Sip-Client 0.0.1",
      "Allow-Events": "presence, kpml, talk",
    };
    this.headers = _.defaults(headers, defaultHeaders);
    return this;
  };

  Message.prototype.inc_cseq = function() {
    return this.headers.cseq.seq += 1;
  };

  Message.prototype.send = function() {
    this.client.send(this.toString());
    return this;
  };

  Message.prototype.on = function(event, callback) {
    return this.events[event].push(callback);
  };

  Message.prototype.sip = function() {
    return {
      method: this.method,
      uri: this.uri,
      headers: this.headers
    };
  };

  Message.prototype.toString = function() {
    return sip.stringify(this.sip());
  };

  module.exports = Client;

}).call(this);
